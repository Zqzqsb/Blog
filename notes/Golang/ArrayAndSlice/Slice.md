---
title: Arrays and Slice in Golang.
createTime: 2024-8-11
tags:
  - Golang
description: 笔记记录了Golang中的切片相关。
---
<br> 笔记记录了Golang中的切片相关。
<!-- more -->

## 概述

切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。

切片是可索引的，并且可以由 `len()` 函数获取长度。

给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 **长度可变的数组**。

###  声明

`var identifier []type`  (不需要说明长度)。

### 初始化

`var slice1 []type = arr1[start:end]` (左闭右开)。

### 通过数组创建切片

`s := [3]int{1,2,3}[:]`   , `s := []int{1,2,3}`  , `var x = []int{2, 3, 5, 7, 11}` 这些写法是等价的。

### 容量

`cap(s)` 是从`s[0]`到数组末尾的长度。

### 切片的增长

切片只能向后移动

```golang
slice1 = slice1[0:cap(slice1)] // 从原来的起始位置增长到原始数组的末尾
```

```golang
slice1 = slice1[1:] // 将slice的头部往前移动一位，尾部不变
```

```golang
slice1 = slice1[1:len(slice1)+1] // 将slice向后滑动一位 可能会溢出
```


### 传递参数

如果你有一个函数需要对数组做操作，你可能总是需要把参数声明为切片。当你调用该函数时，把数组分片，创建为一个 切片引用并传递给该函数。这里有一个计算数组元素和的方法:

```golang
func sum(a []int) int {
	s := 0
	for i := 0; i < len(a); i++ {
		s += a[i]
	}
	return s
}

func main() {
	var arr = [5]int{0, 1, 2, 3, 4}
	sum(arr[:])
}
```

## 使用`make`创造切片

```golang
slice1 := make([]type ,  len)
```

这里`len`是数组长度，也是slice的初始长度。

```golang
slice1 := make([]type , len , cap)
```

`len`是切片长度，`cap`是数组长度, 切片的首个元素将和数组的首个元素对齐。

> 这点很好理解，因为`cap`标志了切片可以在数组中扩展的最大长度。


## `make()` 和 `new()`

二者都是在堆上分配内存，但是它们的行为不同，也适用于不同的类型。

### make()

1. 用于创建 slice、map 和 channel 这三种引用类型的数据结构。
2. `make()` 返回的是已初始化、内存已分配的数据结构。
3. `make()` 接受两个参数，第一个参数是类型，第二个参数是长度、容量等初始化参数。
4. `make()`会初始化数据结构，并根据需要分配内存。

**例子**

```golang
slice := make([]int , 5, 10)
```

### new()

1. 用于分配内存，返回的是指向零值的指针。
2. `new()` 只有一个参数，是类型，返回一个指向该类型的零值的指针。
3. `new()` 只分配内存，不进行初始化，返回的指针指向零值。

**例子** 

```golang
ptr := new(int)
```
### 区别总结

1. `make()` 适用于 slice、map 和 channel 的初始化，返回已初始化的数据结构。
2. `new()` 适用于任何类型的内存分配，返回指向零值的指针。
3. `make()` 初始化数据结构，`new()` 只分配内存。
4. 在 Go 中，通常使用 `make()` 初始化引用类型的数据结构，而使用 `new()` 分配基本类型的内存。

## bytes包

`bytes` 包提供了对字节切片（slice of bytes）的操作和功能。这个包包含了许多用于处理字节数据的方法，可以方便地进行字节数据的读取、写入、拼接、比较等操作。

以下是 `bytes` 包中一些常用函数和方法的简要介绍：

1. **`Buffer` 类型**
    - `bytes.Buffer` 是一个用于操作字节数据的缓冲区，可以用于动态地构建字节数据。
    - 通过 `bytes.NewBuffer()` 函数进行初始化，或者直接使用 `var buf bytes.Buffer` 进行声明。
3. **读取和写入**
    - `Write()`：向缓冲区中写入字节数据。
    - `WriteString()`：向缓冲区中写入字符串。
    - `Read()`：从缓冲区中读取字节数据。
    - `ReadString()`：从缓冲区中读取字符串。
3. **拼接和连接**
    - `Join()`：连接多个字节切片为一个字节切片。
    - `Concat()`：连接多个字节切片为一个新的字节切片。
4. **查找和比较**
    - `Contains()`：判断字节切片是否包含指定的子字节切片。
    - `Index()`：返回子字节切片在父字节切片中第一次出现的索引。
    - `Equal()`：比较两个字节切片是否相等。
5. **转换**
    - `Runes()`：将字节切片转换为 Unicode 字符切片。
    - `Trim()`：去掉字节切片中指定字符集的前缀和后缀。
6. **其他功能**
    - `ToUpper()`：将字节切片中的字母字符转换为大写。
    - `ToLower()`：将字节切片中的字母字符转换为小写。
